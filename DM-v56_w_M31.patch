diff -c source/B_field_3D_model.cc /home/aegorov/g56o/source/B_field_3D_model.cc
*** source/B_field_3D_model.cc	2021-11-21 15:23:39.382236656 +0100
--- /home/aegorov/g56o/source/B_field_3D_model.cc	2021-11-30 22:19:15.985705181 +0100
***************
*** 48,295 ****
  
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  
-  if(name == "M31-MIN")
-   {
-     double zscale, mf;
-     double r=sqrt(x*x+y*y);
-     zscale=parameters[2]; // kpc
-     
-    if(r<=0.4) mf = 14e-6*exp(-fabs(z)/zscale);
-    if(r>0.4 && r<=0.8) mf = (12*r+9)*1e-6*exp(-fabs(z)/zscale);
-    if(r>0.8 && r<=1) mf = 19e-6*exp(-fabs(z)/zscale);
-    if(r>1 && r<=6) mf = (-2.1*r+21)*1e-6*exp(-fabs(z)/zscale);
-    if(r>6) mf = (-0.36*r+11)*1e-6*exp(-fabs(z)/zscale);
-  
-    // the regular field is zero
-    Breg =0.0;
-    Bregx=0.0;
-    Bregy=0.0;
-    Bregz=0.0;
- 
-    Bran=mf;
-    Branx=Bran;  // put all field in x-direction (has no significance)
-    Brany=0.0;
-    Branz=0.0;
- 
-    theta=0.0;
-    phi  =0.0;
-    
-    if(parameters[9]==1) cout<<"r="<<r<<" z="<<z<<" MF="<<mf<<endl;	
-   } //M31-MIN
-   
-   if(name == "M31-MED")
-   {
-     double zscale, mf, amf=0.42, bmf=0.14, amf1=0.84, bmf1=0.28;
-     double r=sqrt(x*x+y*y);
-     zscale=parameters[2]; // kpc
-     
-    if(r<=amf && fabs(z)<=bmf*sqrt(1-r*r/(amf*amf))) mf = 50e-6;  //центр. зона
-    
-    if(round(r*10)/10==0.0 && round(fabs(z)*100)/100==0.15) mf = 47e-6; //переходная зона
-    if(round(r*10)/10==0.0 && round(fabs(z)*100)/100==0.20) mf = 34e-6;
-    if(round(r*10)/10==0.0 && round(fabs(z)*100)/100==0.25) mf = 21e-6;
-    if(round(r*100)/100==0.05 && round(fabs(z)*100)/100==0.15) mf = 47e-6;
-    if(round(r*100)/100==0.05 && round(fabs(z)*100)/100==0.20) mf = 34e-6;
-    if(round(r*100)/100==0.05 && round(fabs(z)*100)/100==0.25) mf = 21e-6;
-    if(round(r*10)/10==0.1 && round(fabs(z)*100)/100==0.15) mf = 46e-6;
-    if(round(r*10)/10==0.1 && round(fabs(z)*100)/100==0.20) mf = 34e-6;
-    if(round(r*10)/10==0.1 && round(fabs(z)*100)/100==0.25) mf = 21e-6;
-    if(round(r*100)/100==0.15 && round(fabs(z)*100)/100==0.15) mf = 45e-6;
-    if(round(r*100)/100==0.15 && round(fabs(z)*100)/100==0.20) mf = 33e-6;
-    if(round(r*100)/100==0.15 && round(fabs(z)*100)/100==0.25) mf = 20e-6;
-    if(round(r*10)/10==0.2 && round(fabs(z)*100)/100==0.15) mf = 43e-6;
-    if(round(r*10)/10==0.2 && round(fabs(z)*100)/100==0.20) mf = 31e-6;
-    if(round(r*10)/10==0.2 && round(fabs(z)*100)/100==0.25) mf = 19e-6;
-    if(round(r*100)/100==0.25 && round(fabs(z)*100)/100==0.15) mf = 41e-6;
-    if(round(r*100)/100==0.25 && round(fabs(z)*100)/100==0.20) mf = 30e-6;
-    if(round(r*100)/100==0.25 && round(fabs(z)*100)/100==0.25) mf = 18e-6;
-    if(round(r*10)/10==0.3 && round(fabs(z)*100)/100==0.10) mf = 50e-6;
-    if(round(r*10)/10==0.3 && round(fabs(z)*100)/100==0.15) mf = 39e-6;
-    if(round(r*10)/10==0.3 && round(fabs(z)*100)/100==0.20) mf = 28e-6;
-    if(round(r*10)/10==0.3 && round(fabs(z)*100)/100==0.25) mf = 16e-6;
-    if(round(r*100)/100==0.35 && round(fabs(z)*100)/100==0.10) mf = 46e-6;
-    if(round(r*100)/100==0.35 && round(fabs(z)*100)/100==0.15) mf = 36e-6;
-    if(round(r*100)/100==0.35 && round(fabs(z)*100)/100==0.20) mf = 25e-6;
-    if(round(r*100)/100==0.35 && round(fabs(z)*100)/100==0.25) mf = 15e-6;
-    if(round(r*10)/10==0.4 && round(fabs(z)*100)/100==0.05) mf = 49e-6;
-    if(round(r*10)/10==0.4 && round(fabs(z)*100)/100==0.10) mf = 41e-6;
-    if(round(r*10)/10==0.4 && round(fabs(z)*100)/100==0.15) mf = 33e-6;
-    if(round(r*10)/10==0.4 && round(fabs(z)*100)/100==0.20) mf = 23e-6;
-    if(round(r*100)/100==0.45 && round(fabs(z)*100)/100==0.00) mf = 48e-6;
-    if(round(r*100)/100==0.45 && round(fabs(z)*100)/100==0.05) mf = 43e-6;
-    if(round(r*100)/100==0.45 && round(fabs(z)*100)/100==0.10) mf = 37e-6;
-    if(round(r*100)/100==0.45 && round(fabs(z)*100)/100==0.15) mf = 29e-6;
-    if(round(r*100)/100==0.45 && round(fabs(z)*100)/100==0.20) mf = 21e-6;
-    if(round(r*10)/10==0.5 && round(fabs(z)*100)/100==0.00) mf = 44e-6;
-    if(round(r*10)/10==0.5 && round(fabs(z)*100)/100==0.05) mf = 38e-6;
-    if(round(r*10)/10==0.5 && round(fabs(z)*100)/100==0.10) mf = 33e-6;
-    if(round(r*10)/10==0.5 && round(fabs(z)*100)/100==0.15) mf = 26e-6;
-    if(round(r*10)/10==0.5 && round(fabs(z)*100)/100==0.20) mf = 19e-6;
-    if(round(r*100)/100==0.55 && round(fabs(z)*100)/100==0.00) mf = 41e-6;
-    if(round(r*100)/100==0.55 && round(fabs(z)*100)/100==0.05) mf = 34e-6;
-    if(round(r*100)/100==0.55 && round(fabs(z)*100)/100==0.10) mf = 29e-6;
-    if(round(r*100)/100==0.55 && round(fabs(z)*100)/100==0.15) mf = 24e-6;
-    if(round(r*100)/100==0.55 && round(fabs(z)*100)/100==0.20) mf = 17e-6;
-    if(round(r*10)/10==0.6 && round(fabs(z)*100)/100==0.00) mf = 37e-6;
-    if(round(r*10)/10==0.6 && round(fabs(z)*100)/100==0.05) mf = 31e-6;
-    if(round(r*10)/10==0.6 && round(fabs(z)*100)/100==0.10) mf = 27e-6;
-    if(round(r*10)/10==0.6 && round(fabs(z)*100)/100==0.15) mf = 21e-6;
-    if(round(r*100)/100==0.65 && round(fabs(z)*100)/100==0.00) mf = 34e-6;
-    if(round(r*100)/100==0.65 && round(fabs(z)*100)/100==0.05) mf = 28e-6;
-    if(round(r*100)/100==0.65 && round(fabs(z)*100)/100==0.10) mf = 24e-6;
-    if(round(r*100)/100==0.65 && round(fabs(z)*100)/100==0.15) mf = 19e-6;
-    if(round(r*10)/10==0.7 && round(fabs(z)*100)/100==0.00) mf = 30e-6;
-    if(round(r*10)/10==0.7 && round(fabs(z)*100)/100==0.05) mf = 26e-6;
-    if(round(r*10)/10==0.7 && round(fabs(z)*100)/100==0.10) mf = 22e-6;
-    if(round(r*10)/10==0.7 && round(fabs(z)*100)/100==0.15) mf = 17e-6;
-    if(round(r*100)/100==0.75 && round(fabs(z)*100)/100==0.00) mf = 27e-6;
-    if(round(r*100)/100==0.75 && round(fabs(z)*100)/100==0.05) mf = 23e-6;
-    if(round(r*100)/100==0.75 && round(fabs(z)*100)/100==0.10) mf = 20e-6;
-    if(round(r*10)/10==0.8 && round(fabs(z)*100)/100==0.00) mf = 23e-6;
-    if(round(r*10)/10==0.8 && round(fabs(z)*100)/100==0.05) mf = 21e-6;                                                  
-    
-    if(r<=amf && fabs(z)>=bmf1*sqrt(1-r*r/(amf1*amf1))) mf = 17e-6*exp(-fabs(z)/zscale);  //внешняя зона  
-    if(r>amf && r<amf1 && fabs(z)>=bmf1*sqrt(1-r*r/(amf1*amf1))) mf = (9.1*r+13)*1e-6*exp(-fabs(z)/zscale);
-    if(r>=amf1 && r<=1) mf = 21e-6*exp(-fabs(z)/zscale);
-    if(r>1 && r<=6) mf = (-2.4*r+23)*1e-6*exp(-fabs(z)/zscale);
-    if(r>6) mf = (-0.27*r+11)*1e-6*exp(-fabs(z)/zscale);
-  
-    // the regular field is zero
-    Breg =0.0;
-    Bregx=0.0;
-    Bregy=0.0;
-    Bregz=0.0;
- 
-    Bran=mf;
-    Branx=Bran;  // put all field in x-direction (has no significance)
-    Brany=0.0;
-    Branz=0.0;
- 
-    theta=0.0;
-    phi  =0.0;
-    
-    if(parameters[9]==1) cout<<"r="<<r<<" z="<<z<<" MF="<<mf<<endl;
-   } //M31-MED
-   
-   if(name == "M31-MAX")
-   {
-     double zscale, mf, amf=0.42, bmf=0.14, amf1=0.84, bmf1=0.28;
-     double r=sqrt(x*x+y*y);
-     zscale=parameters[2]; // kpc
-     
-    if(r<=amf && fabs(z)<=bmf*sqrt(1-r*r/(amf*amf))) mf = 100e-6;  //центр. зона
-    
-    if(round(r*10)/10==0.0 && round(fabs(z)*100)/100==0.15) mf = 94e-6; //переходная зона
-    if(round(r*10)/10==0.0 && round(fabs(z)*100)/100==0.20) mf = 64e-6;
-    if(round(r*10)/10==0.0 && round(fabs(z)*100)/100==0.25) mf = 35e-6;
-    if(round(r*100)/100==0.05 && round(fabs(z)*100)/100==0.15) mf = 93e-6;
-    if(round(r*100)/100==0.05 && round(fabs(z)*100)/100==0.20) mf = 64e-6;
-    if(round(r*100)/100==0.05 && round(fabs(z)*100)/100==0.25) mf = 34e-6;
-    if(round(r*10)/10==0.1 && round(fabs(z)*100)/100==0.15) mf = 92e-6;
-    if(round(r*10)/10==0.1 && round(fabs(z)*100)/100==0.20) mf = 62e-6;
-    if(round(r*10)/10==0.1 && round(fabs(z)*100)/100==0.25) mf = 33e-6;
-    if(round(r*100)/100==0.15 && round(fabs(z)*100)/100==0.15) mf = 89e-6;
-    if(round(r*100)/100==0.15 && round(fabs(z)*100)/100==0.20) mf = 60e-6;
-    if(round(r*100)/100==0.15 && round(fabs(z)*100)/100==0.25) mf = 31e-6;
-    if(round(r*10)/10==0.2 && round(fabs(z)*100)/100==0.15) mf = 85e-6;
-    if(round(r*10)/10==0.2 && round(fabs(z)*100)/100==0.20) mf = 57e-6;
-    if(round(r*10)/10==0.2 && round(fabs(z)*100)/100==0.25) mf = 29e-6;
-    if(round(r*100)/100==0.25 && round(fabs(z)*100)/100==0.15) mf = 80e-6;
-    if(round(r*100)/100==0.25 && round(fabs(z)*100)/100==0.20) mf = 53e-6;
-    if(round(r*100)/100==0.25 && round(fabs(z)*100)/100==0.25) mf = 26e-6;
-    if(round(r*10)/10==0.3 && round(fabs(z)*100)/100==0.10) mf = 99e-6;
-    if(round(r*10)/10==0.3 && round(fabs(z)*100)/100==0.15) mf = 74e-6;
-    if(round(r*10)/10==0.3 && round(fabs(z)*100)/100==0.20) mf = 49e-6;
-    if(round(r*10)/10==0.3 && round(fabs(z)*100)/100==0.25) mf = 23e-6;
-    if(round(r*100)/100==0.35 && round(fabs(z)*100)/100==0.10) mf = 90e-6;
-    if(round(r*100)/100==0.35 && round(fabs(z)*100)/100==0.15) mf = 68e-6;
-    if(round(r*100)/100==0.35 && round(fabs(z)*100)/100==0.20) mf = 44e-6;
-    if(round(r*100)/100==0.35 && round(fabs(z)*100)/100==0.25) mf = 19e-6;
-    if(round(r*10)/10==0.4 && round(fabs(z)*100)/100==0.05) mf = 98e-6;
-    if(round(r*10)/10==0.4 && round(fabs(z)*100)/100==0.10) mf = 80e-6;
-    if(round(r*10)/10==0.4 && round(fabs(z)*100)/100==0.15) mf = 60e-6;
-    if(round(r*10)/10==0.4 && round(fabs(z)*100)/100==0.20) mf = 38e-6;
-    if(round(r*100)/100==0.45 && round(fabs(z)*100)/100==0.00) mf = 95e-6;
-    if(round(r*100)/100==0.45 && round(fabs(z)*100)/100==0.05) mf = 84e-6;
-    if(round(r*100)/100==0.45 && round(fabs(z)*100)/100==0.10) mf = 70e-6;
-    if(round(r*100)/100==0.45 && round(fabs(z)*100)/100==0.15) mf = 53e-6;
-    if(round(r*100)/100==0.45 && round(fabs(z)*100)/100==0.20) mf = 33e-6;
-    if(round(r*10)/10==0.5 && round(fabs(z)*100)/100==0.00) mf = 85e-6;
-    if(round(r*10)/10==0.5 && round(fabs(z)*100)/100==0.05) mf = 72e-6;
-    if(round(r*10)/10==0.5 && round(fabs(z)*100)/100==0.10) mf = 60e-6;
-    if(round(r*10)/10==0.5 && round(fabs(z)*100)/100==0.15) mf = 45e-6;
-    if(round(r*10)/10==0.5 && round(fabs(z)*100)/100==0.20) mf = 28e-6;
-    if(round(r*100)/100==0.55 && round(fabs(z)*100)/100==0.00) mf = 76e-6;
-    if(round(r*100)/100==0.55 && round(fabs(z)*100)/100==0.05) mf = 62e-6;
-    if(round(r*100)/100==0.55 && round(fabs(z)*100)/100==0.10) mf = 52e-6;
-    if(round(r*100)/100==0.55 && round(fabs(z)*100)/100==0.15) mf = 39e-6;
-    if(round(r*100)/100==0.55 && round(fabs(z)*100)/100==0.20) mf = 23e-6;
-    if(round(r*10)/10==0.6 && round(fabs(z)*100)/100==0.00) mf = 67e-6;
-    if(round(r*10)/10==0.6 && round(fabs(z)*100)/100==0.05) mf = 54e-6;
-    if(round(r*10)/10==0.6 && round(fabs(z)*100)/100==0.10) mf = 44e-6;
-    if(round(r*10)/10==0.6 && round(fabs(z)*100)/100==0.15) mf = 32e-6;
-    if(round(r*100)/100==0.65 && round(fabs(z)*100)/100==0.00) mf = 58e-6;
-    if(round(r*100)/100==0.65 && round(fabs(z)*100)/100==0.05) mf = 47e-6;
-    if(round(r*100)/100==0.65 && round(fabs(z)*100)/100==0.10) mf = 38e-6;
-    if(round(r*100)/100==0.65 && round(fabs(z)*100)/100==0.15) mf = 27e-6;
-    if(round(r*10)/10==0.7 && round(fabs(z)*100)/100==0.00) mf = 49e-6;
-    if(round(r*10)/10==0.7 && round(fabs(z)*100)/100==0.05) mf = 40e-6;
-    if(round(r*10)/10==0.7 && round(fabs(z)*100)/100==0.10) mf = 32e-6;
-    if(round(r*10)/10==0.7 && round(fabs(z)*100)/100==0.15) mf = 22e-6;
-    if(round(r*100)/100==0.75 && round(fabs(z)*100)/100==0.00) mf = 40e-6;
-    if(round(r*100)/100==0.75 && round(fabs(z)*100)/100==0.05) mf = 34e-6;
-    if(round(r*100)/100==0.75 && round(fabs(z)*100)/100==0.10) mf = 26e-6;
-    if(round(r*10)/10==0.8 && round(fabs(z)*100)/100==0.00) mf = 31e-6;
-    if(round(r*10)/10==0.8 && round(fabs(z)*100)/100==0.05) mf = 27e-6;                                                  
-    
-    if(r<=amf && fabs(z)>=bmf1*sqrt(1-r*r/(amf1*amf1))) mf = 20e-6*exp(-fabs(z)/zscale);  //внешняя зона  
-    if(r>amf && r<amf1 && fabs(z)>=bmf1*sqrt(1-r*r/(amf1*amf1))) mf = (9.5*r+16)*1e-6*exp(-fabs(z)/zscale);
-    if(r>=amf1 && r<=1) mf = 24e-6*exp(-fabs(z)/zscale);
-    if(r>1 && r<=6) mf = (-2.8*r+27)*1e-6*exp(-fabs(z)/zscale);
-    if(r>6) mf = (-0.35*r+12)*1e-6*exp(-fabs(z)/zscale);
-  
-    // the regular field is zero
-    Breg =0.0;
-    Bregx=0.0;
-    Bregy=0.0;
-    Bregz=0.0;
- 
-    Bran=mf;
-    Branx=Bran;  // put all field in x-direction (has no significance)
-    Brany=0.0;
-    Branz=0.0;
- 
-    theta=0.0;
-    phi  =0.0;
-    
-    if(parameters[9]==1) cout<<"r="<<r<<" z="<<z<<" MF="<<mf<<endl;
-   } //M31-MAX
-   
-   if(name == "M31-test")
-   {
-     double mf;
-     double r=sqrt(x*x+y*y);
-     
-     mf = (7e-6+43e-6*exp(-r/1.347))*exp(-fabs(z)/1.2);
-  
-    // the regular field is zero
-    Breg =0.0;
-    Bregx=0.0;
-    Bregy=0.0;
-    Bregz=0.0;
- 
-    Bran=mf;
-    Branx=Bran;  // put all field in x-direction (has no significance)
-    Brany=0.0;
-    Branz=0.0;
- 
-    theta=0.0;
-    phi  =0.0;
-    
-    if(parameters[9]==1) cout<<"r="<<r<<" z="<<z<<" MF="<<mf<<endl;	
-   } //M31-test
-   
-   
  
    if(name == "test")
    {
--- 48,53 ----
***************
*** 444,452 ****
     phi  =0.0;
  
    } //galprop_original
!   
!   
!    ///////////////////////////////////////////////////////////////////////////////////////////////////////
  
      // WMAP regular field strength and direction (x,y,z); right handed system; Sun in x; B in Page et al. 2007 adapted to this coordinate system
      // from Elena Orlando: but she says this formulation is invalid: keep for reference
--- 202,209 ----
     phi  =0.0;
  
    } //galprop_original
! 
!   ///////////////////////////////////////////////////////////////////////////////////////////////////////
  
      // WMAP regular field strength and direction (x,y,z); right handed system; Sun in x; B in Page et al. 2007 adapted to this coordinate system
      // from Elena Orlando: but she says this formulation is invalid: keep for reference
diff -c source/create_galaxy.cc /home/aegorov/g56o/source/create_galaxy.cc
*** source/create_galaxy.cc	2021-01-26 20:23:41.052799277 +0100
--- /home/aegorov/g56o/source/create_galaxy.cc	2021-11-30 22:17:32.462778932 +0100
***************
*** 79,86 ****
  
    //Moved from create_galaxy  Gulli20071003
    
-   if (galdef.DM_int9 == 0) {             //AE20201229
-   
    galaxy.nu_synch_min = galdef.nu_synch_min;
    galaxy.nu_synch_max = galdef.nu_synch_max;
    galaxy.nu_synch_factor = galdef.nu_synch_factor;
--- 79,84 ----
***************
*** 90,119 ****
    
    for (int iS = 0; iS < galaxy.n_nu_synchgrid; ++iS)
      galaxy.nu_synch[iS] = exp(log(galaxy.nu_synch_min) + iS*log(galaxy.nu_synch_factor));
- 	}
- 	//AE20201229
- else {
-      galaxy.n_nu_synchgrid = galdef.DM_int9;
-      //galaxy.nu_synch = new double[galaxy.n_nu_synchgrid];
-      galaxy.nu_synch.resize(galaxy.n_nu_synchgrid);
- 	 
- 	 ostringstream sBuf;
-     sBuf << "Synchrotron frequency grid: ";
- 
-     for (int inusynch = 0; inusynch < galaxy.n_nu_synchgrid; ++inusynch) {
-       
-       galaxy.nu_synch[inusynch] = galdef.DM_double3[inusynch];
-       
-       sBuf << galaxy.nu_synch[inusynch] << " ";
-      
-        }
- 
-     galaxy.nu_synch_min =   galaxy.nu_synch[0];
-     galaxy.nu_synch_max =   galaxy.nu_synch[galaxy.n_nu_synchgrid-1];
-     galaxy.nu_synch_factor = 1;
-       
-     INFO(sBuf.str());
-       }  //  else DM_int9                AE20201229
    
    // GAS and B-FIELD DISTRIBUTION
    
--- 88,93 ----
diff -c source/Galdef.cc /home/aegorov/g56o/source/Galdef.cc
*** source/Galdef.cc	2021-01-26 20:23:41.055799332 +0100
--- /home/aegorov/g56o/source/Galdef.cc	2021-11-30 22:19:15.893703468 +0100
***************
*** 796,805 ****
      os<<"  DM_double0            ="<<DM_double0           <<endl;
      os<<"  DM_double1            ="<<DM_double1           <<endl;
      os<<"  DM_double2            ="<<DM_double2           <<endl;
!     os<<"  DM_double3    =";
!     for ( int i=0;i<DM_double3.size();i++ ) {
!        os<< DM_double3[i]<<"  ";
!     }     os<<endl;   //AE20201229
      os<<"  DM_double4            ="<<DM_double4           <<endl;
      os<<"  DM_double5            ="<<DM_double5           <<endl;
      os<<"  DM_double6            ="<<DM_double6           <<endl;
--- 796,802 ----
      os<<"  DM_double0            ="<<DM_double0           <<endl;
      os<<"  DM_double1            ="<<DM_double1           <<endl;
      os<<"  DM_double2            ="<<DM_double2           <<endl;
!     os<<"  DM_double3            ="<<DM_double3           <<endl;
      os<<"  DM_double4            ="<<DM_double4           <<endl;
      os<<"  DM_double5            ="<<DM_double5           <<endl;
      os<<"  DM_double6            ="<<DM_double6           <<endl;
diff -c source/Galdef.h /home/aegorov/g56o/source/Galdef.h
*** source/Galdef.h	2021-01-26 20:23:41.053799296 +0100
--- /home/aegorov/g56o/source/Galdef.h	2021-11-30 22:18:21.680694729 +0100
***************
*** 203,211 ****
    int DM_antiprotons;                   // 1=compute antiprotons from DM
    int DM_gammas;                        // 1=compute gamma rays from DM
    double                                // user-defined params of DM (double)
!     DM_double0, DM_double1, DM_double2, DM_double4,
      DM_double5, DM_double6, DM_double7, DM_double8, DM_double9;
- 	std::vector<double> DM_double3;     //AE20201229
    int                                   // user-defined params of DM (int)
      DM_int0, DM_int1, DM_int2, DM_int3, DM_int4,
      DM_int5, DM_int6, DM_int7, DM_int8, DM_int9;
--- 203,210 ----
    int DM_antiprotons;                   // 1=compute antiprotons from DM
    int DM_gammas;                        // 1=compute gamma rays from DM
    double                                // user-defined params of DM (double)
!     DM_double0, DM_double1, DM_double2, DM_double3, DM_double4,
      DM_double5, DM_double6, DM_double7, DM_double8, DM_double9;
    int                                   // user-defined params of DM (int)
      DM_int0, DM_int1, DM_int2, DM_int3, DM_int4,
      DM_int5, DM_int6, DM_int7, DM_int8, DM_int9;
diff -c source/Galprop.h /home/aegorov/g56o/source/Galprop.h
*** source/Galprop.h	2021-01-26 20:23:41.052799277 +0100
--- /home/aegorov/g56o/source/Galprop.h	2021-11-30 22:17:32.711783566 +0100
***************
*** 52,61 ****
    // DM routines IMOS20050912
    int gen_DM_source ( Particle& );
    int gen_DM_emiss();
!   double DM_profile ( double,double,double );
!   double DM_profile_av ( double,double,double,double );   //AE20201229
!   double DM_profile_av ( double,double,double,double,double,double );    //AE20201229
!   double DM_subs_boost ( double, double, double );    //AE20201229
    int store_DM_emiss();
    int store_DM_skymap();
    
--- 52,60 ----
    // DM routines IMOS20050912
    int gen_DM_source ( Particle& );
    int gen_DM_emiss();
!   double DM_profile ( double, double, double );
!   double DM_profile_av ( double,double,double,double,double );
!   double DM_profile_av ( double,double,double,double,double,double,double );
    int store_DM_emiss();
    int store_DM_skymap();
    
diff -c source/gen_DM_source.cc /home/aegorov/g56o/source/gen_DM_source.cc
*** source/gen_DM_source.cc	2022-02-02 09:28:33.026219670 +0100
--- /home/aegorov/g56o/source/gen_DM_source.cc	2021-11-30 22:17:57.488244580 +0100
***************
*** 6,16 ****
  
  //**"****!****"****!****"****!****"****!****"****!****"****!****"****!****"****|
  // The routine gen_DM_source calculates the source functions of the products of the
! // dark matter (DM) particle annihilation [c/(4\pi) cm^-3 s^-1 MeV^-1].
  // The routine can be used to calculate source function of positrons, electrons,
  // and antiprotons.
! // Use gen_DM_emiss to define gamma-ray emissivity (cm^-3 s^-1 MeV^-1 sr^-1)
! // in terms (dn/dEdt *1/4pi), where n is the number density, c is speed of light (AE20131226 - c is removed, sr^-1 is added above - suggested typos).
  // The user must use the parameters DM_double0-9 and DM_int0-9 (galdef-file) to 
  // specify the Galactic DM profile, branching, decay channels, and spectra (see 
  // the template below). The DM profile is defined in the DM_profile routine.
--- 6,16 ----
  
  //**"****!****"****!****"****!****"****!****"****!****"****!****"****!****"****|
  // The routine gen_DM_source calculates the source functions of the products of the
! // dark matter (DM) particle annihilation [cm^-3 s^-1 MeV^-1].
  // The routine can be used to calculate source function of positrons, electrons,
  // and antiprotons.
! // Use gen_DM_emiss to define gamma-ray emissivity (cm^-3 s^-1 MeV^-1)
! // in terms (dn/dEdt *c/4pi), where n is the number density, c is speed of light.
  // The user must use the parameters DM_double0-9 and DM_int0-9 (galdef-file) to 
  // specify the Galactic DM profile, branching, decay channels, and spectra (see 
  // the template below). The DM profile is defined in the DM_profile routine.
***************
*** 19,31 ****
  //
  // See example in Moskalenko I.V., Strong A.W. 1999, Phys. Rev. D 60, 063003
  // and realization below.
- 
- // Modified, improved and updated by Andrey Egorov - 11/29/2013-... .
- 
- //Attention! - DM_profile_av function below bears in fact DM density squared average.
- 
- //Transferred from v54 - AE20201229
- 
  //=="====!===="====!===="====!===="====!===="====!===="====!===="====!===="====!
  using namespace std;
  #include"galprop_classes.h"
--- 19,24 ----
***************
*** 50,254 ****
        <<gcr[0].n_spatial_dimensions<<endl;
    INFO(os.str());
    
!   const double DMmass=galdef.DM_double2,                               // DM particle mass, GeV
!               DMcs_v=galdef.DM_double9;                               // DM <cross_sec*V> -thermally averaged, cm3 s-1
!        double DME0,DMwidth,DMbranching,DMsecondary_spectrum;          // obsolete - needed for DarkSUSY
!  int stat=0, iwm=0, SD_key=galdef.DM_int4, channel_key=galdef.DM_int2;         
! 
!  FILE *fDM;                                               // file with annihilation yields data for p* and ee*
!  const long NsDMy=55242, NDMm=62, NsDMym=891;             // for operation with yields data 
!  long jDMyw=0;
!  double DMy[NsDMy], DMym[NsDMym];                                      
!  const double mt[NDMm] = {5.,6.,8.,10.,15.,20.,25.,30.,40.,50.,60.,70.,80.,90.,100.,110.,120.,130.,140.,150.,160.,180.,200.,220.,240.,260.,280.,300.,330.,360.,
! 400.,450.,500.,550.,600.,650.,700.,750.,800.,900.,1000.,1100.,1200.,1300.,1500.,1700.,2000.,2500.,3000.,4000.,5000.,6000.,7000.,
! 8000.,9000.,10000.,12000.,15000.,20000.,30000.,50000.,100000.};   // masses with tabulated yields
!  const std::string DMDirectory = configure.fFITSDataDirectory+"DM/";
!  std::string filename = DMDirectory;
!  const char *str;
! 
!  //if(strcmp(particle.name,"DM_antiprotons")==0)
!  if("DM_antiprotons" == particle.name)
!    {
!     SD_key=0;
!     switch(channel_key)
!     {
!      case 1: filename += "DM-e-p.dat";
!              str = filename.c_str();	
!              fDM=fopen(str,"r");
!              break; // e^+e^- channel
!      case 2: filename += "DM-mu-p.dat";
!              str = filename.c_str();	
!              fDM=fopen(str,"r");
!              break; // \mu^+\mu^- channel
!      case 3: filename += "DM-tau-p.dat";
!              str = filename.c_str();	
!              fDM=fopen(str,"r");
!              break; // \tau^+\tau^- channel
!      case 4: filename += "DM-q-p.dat";
!              str = filename.c_str();	
!              fDM=fopen(str,"r");
!              break; // qq* channel
!      case 5: filename += "DM-c-p.dat";
!              str = filename.c_str();	
!              fDM=fopen(str,"r");
!              break; // cc* channel
!      case 6: filename += "DM-b-p.dat";
!              str = filename.c_str();	
!              fDM=fopen(str,"r");
!              break; // bb* channel
!      case 7: filename += "DM-t-p.dat";
!              str = filename.c_str();	
!              fDM=fopen(str,"r");
!              break; // tt* channel
!      case 8: filename += "DM-g-p.dat";
!              str = filename.c_str();	
!              fDM=fopen(str,"r");
!              break; // \gamma\gamma channel
!      case 9: filename += "DM-gl-p.dat";
!              str = filename.c_str();	
!              fDM=fopen(str,"r");
!              break; // gg channel
!      case 10: filename += "DM-W-p.dat";
!              str = filename.c_str();	
!              fDM=fopen(str,"r");
!              break; // W^+W^- channel
!      case 11: filename += "DM-Z-p.dat";
!              str = filename.c_str();	
!              fDM=fopen(str,"r");
!              break; // ZZ channel
!      case 12: filename += "DM-h-p.dat";
!              str = filename.c_str();	
!              fDM=fopen(str,"r");
!              break; // hh channel
!     }
!    }
  
!  if(particle.name == "DM_electrons" || particle.name == "DM_positrons")
!    {
!     switch(channel_key)
      {
!      case 1: filename += "DM-e-e.dat";
!              str = filename.c_str();	
!              fDM=fopen(str,"r");
!              break; // e^+e^- channel
!      case 2: filename += "DM-mu-e.dat";
!              str = filename.c_str();	
!              fDM=fopen(str,"r");
!              break; // \mu^+\mu^- channel
!      case 3: filename += "DM-tau-e.dat";
!              str = filename.c_str();	
!              fDM=fopen(str,"r");
!              break; // \tau^+\tau^- channel
!      case 4: filename += "DM-q-e.dat";
!              str = filename.c_str();	
!              fDM=fopen(str,"r");
!              break; // qq* channel
!      case 5: filename += "DM-c-e.dat";
!              str = filename.c_str();	
!              fDM=fopen(str,"r");
!              break; // cc* channel
!      case 6: filename += "DM-b-e.dat";
!              str = filename.c_str();	
!              fDM=fopen(str,"r");
!              break; // bb* channel
!      case 7: filename += "DM-t-e.dat";
!              str = filename.c_str();	
!              fDM=fopen(str,"r");
!              break; // tt* channel
!      case 8: filename += "DM-g-e.dat";
!              str = filename.c_str();	
!              fDM=fopen(str,"r");
!              break; // \gamma\gamma channel
!      case 9: filename += "DM-gl-e.dat";
!              str = filename.c_str();	
!              fDM=fopen(str,"r");
!              break; // gg channel
!      case 10: filename += "DM-W-e.dat";
!              str = filename.c_str();	
!              fDM=fopen(str,"r");
!              break; // W^+W^- channel
!      case 11: filename += "DM-Z-e.dat";
!              str = filename.c_str();	
!              fDM=fopen(str,"r");
!              break; // ZZ channel
!      case 12: filename += "DM-h-e.dat";
!              str = filename.c_str();	
!              fDM=fopen(str,"r");
!              break; // hh channel
!     }
!    } 
  
!  fseek(fDM, 0, SEEK_SET);
!  for (long jDMy=0; jDMy<NsDMy; jDMy++)
!       { 
!        fscanf(fDM, "%lf", &DMy[jDMy]);
!       }
!  fclose(fDM);
  
  
-  for(int ia=0; ia<NDMm; ia++) 
-     {
-      if(DMmass==mt[ia]) 
-        {iwm=ia+1;                                                       // yields preparation from mass analysis
-         break;
-        }
-     }
-  if(iwm>=1)
-    {
-     for(int ib=0; ib<NsDMym; ib++) DMym[ib]=DMy[(iwm-1)*NsDMym+ib];
-    }
-  else
-    {
-     while (DMmass>mt[iwm]) iwm++;
-     for(int ic=0;ic<NsDMym;ic++) DMym[ic]=DMy[(iwm-1)*NsDMym+ic]+((DMy[iwm*NsDMym+ic]-DMy[(iwm-1)*NsDMym+ic])*(DMmass-mt[iwm-1]))/(mt[iwm]-mt[iwm-1]);
-    } 
-   
  // assign the source function (2D)
  
     if(galaxy.n_spatial_dimensions==2)
       {
- #pragma omp parallel for schedule(dynamic) default(shared) private(jDMyw)
         for(int ir=0; ir<gcr[0].n_rgrid; ir++)
  	 {
  	   for(int iz=0; iz<gcr[0].n_zgrid; iz++)
  	     {
  	       for(int ip=0; ip<particle.n_pgrid; ip++)
  		 {
  		   if(galdef.DM_int1==9) // Green's function to work with DarkSUSY IMOS20060901
  		     {
  		       if(DME0<particle.Ekin[ip] || DME0/DMwidth>particle.Ekin[ip]) continue;
  		       particle.secondary_source_function.d2[ir][iz].s[ip]
! 			 +=DM_profile_av(galaxy.r[ir], galaxy.z[iz], galaxy.dr, galaxy.dz)
  			 *DMsecondary_spectrum*DMbranching/4./Pi*C;
  		       continue;
! 		     } // end of DarkSUSY area
  		   if(particle.Etot[ip]*1.e-3<=DMmass) 
!                      {
!                        if(particle.Ekin[ip]*1.e-3<pow(10,-8.9)*DMmass)
!                           particle.secondary_source_function.d2[ir][iz].s[ip]+=0;
!                        else
!                            {
!                             jDMyw=lround(100.*log10(particle.Ekin[ip]/(DMmass*1000.)))+NsDMym-1;
! 		            particle.secondary_source_function.d2[ir][iz].s[ip]+=(1.+SD_key)*(C/(4.*Pi))*0.5*DMcs_v*
!                             DM_profile_av(galaxy.r[ir], galaxy.z[iz], galaxy.dr, galaxy.dz)*pow(DMmass,-2.)*DM_subs_boost(galaxy.r[ir], 0., galaxy.z[iz])*DMym[jDMyw]/(log(10.)*particle.Ekin[ip]);
!                            } //else  
!                      } // if 
  		 } // ip
  	     }  //  iz
  	 }  //  ir
- if(galdef.verbose>=3)
- for(int ir=0; ir<gcr[0].n_rgrid; ir++)	  {
- for(int iz=0; iz<gcr[0].n_zgrid; iz++)    {
- for(int ip=0; ip<particle.n_pgrid; ip++)  {
- cout<<galaxy.r[ir]<<" r "<<galaxy.z[iz]<<" z "<<particle.Ekin[ip]<<" Ekin "<<DM_profile_av(galaxy.r[ir], galaxy.z[iz], galaxy.dr, galaxy.dz)<<" rho_{DM}_sq_av "<<DM_subs_boost(galaxy.r[ir], 0., galaxy.z[iz])<<" B(r) "<<particle.secondary_source_function.d2[ir][iz].s[ip]<<endl; }}}  //test printout
       }  //  particle.n_spatial_dimensions==2
     
  // assign the source function (3D)
  
     if(galaxy.n_spatial_dimensions==3)
       {
! #pragma omp parallel for schedule(dynamic) default(shared) private(jDMyw)
!      for(int ix=0; ix<gcr[0].n_xgrid; ix++)
  	 {
  	   for(int iy=0; iy<gcr[0].n_ygrid; iy++)
  	     {
--- 43,127 ----
        <<gcr[0].n_spatial_dimensions<<endl;
    INFO(os.str());
    
!   double DMwidth,DMbranching,   // annihilation product distribution
!     DMsecondary_spectrum,       // spectrum of secondaries from DM annihilation
!     DME0,                       // delta function energy used for Green's function
!     DMmass  =galdef.DM_double2, // DM particle mass
!     DMcs_v  =galdef.DM_double9, // DM <cross_sec*V> -thermally overaged, cm3 s-1 
!     dzz=0.01;                   // kpc, gas averaging step
!   int stat=0;
  
!   // define the spectra of annihilation products: positrons, electrons, antiprotons
!   
!   if("DM_positrons" == particle.name) //strcmp(particle.name,"DM_positrons")==0)
      {
!        DMwidth     =galdef.DM_double3;
!        DMbranching =galdef.DM_double4;
!      }
  
!   if("DM_electrons" == particle.name) //strcmp(particle.name,"DM_electrons")==0)
!      {
!        DMwidth     =galdef.DM_double5;
!        DMbranching =galdef.DM_double6;
!      }
  
+   if("DM_antiprotons" == particle.name) //strcmp(particle.name,"DM_antiprotons")==0)
+      {
+        DMwidth     =galdef.DM_double7;
+        DMbranching =galdef.DM_double8;
+      }
  
  // assign the source function (2D)
  
     if(galaxy.n_spatial_dimensions==2)
       {
         for(int ir=0; ir<gcr[0].n_rgrid; ir++)
  	 {
  	   for(int iz=0; iz<gcr[0].n_zgrid; iz++)
  	     {
  	       for(int ip=0; ip<particle.n_pgrid; ip++)
  		 {
+ // test of electron propagation vs analytical calculations IMOS20061030
+ // to run test, assign galdef.DM_int0=99, other parameters:
+ // galdef.DM_double6 - the half thickness of the disk source distribution (e.g. 0.1 kpc), the source 
+ //                     distribution is uniform within the disk; normalization =1 at 1 GeV
+ // galdef.DM_double7 - the photon field energy density (e.g. 1 eV/cc)
+ // galdef.DM_double8 - the injection spectral index of electrons (e.g. 2.4)
+ 		   if(abs(galdef.DM_int0)==99 && particle.A==0) 
+ 		     {
+ 		       if("DM_electrons" == particle.name) //strcmp(particle.name,"DM_electrons")==0) //numerical  solution "DM_electrons"
+                           if (particle.Ekin[ip] > galdef.inj_Ekin_min && particle.Ekin[ip] < galdef.inj_Ekin_max) {
+ 			 particle.secondary_source_function.d2[ir][iz].s[ip]= 
+ 			   (galdef.DM_double6 <= fabs(galaxy.z[iz])) ? 0.:
+ 			   C/4./Pi*pow(particle.Ekin[ip]*1e-3,-galdef.DM_double8); //The spectrum is normalized at 1 GeV
+                           }
+ 			 if("DM_positrons" == particle.name) //strcmp(particle.name,"DM_positrons")==0) //analytical solution "DM_positrons"
+ 			 particle.secondary_source_function.d2[ir][iz].s[ip]=0.;
+ 		       continue;		     
+ 		     }
+ // end of the test area
  		   if(galdef.DM_int1==9) // Green's function to work with DarkSUSY IMOS20060901
  		     {
  		       if(DME0<particle.Ekin[ip] || DME0/DMwidth>particle.Ekin[ip]) continue;
  		       particle.secondary_source_function.d2[ir][iz].s[ip]
! 			 +=pow(DM_profile_av(galaxy.r[ir], galaxy.z[iz], galaxy.dr, galaxy.dz, dzz),2)
  			 *DMsecondary_spectrum*DMbranching/4./Pi*C;
  		       continue;
! 		     }
  		   if(particle.Etot[ip]*1.e-3<=DMmass) 
! 		     particle.secondary_source_function.d2[ir][iz].s[ip]+= DMcs_v*
! 		       pow(DM_profile_av(galaxy.r[ir], galaxy.z[iz], galaxy.dr, galaxy.dz, dzz)/DMmass,2)
! 		       *C/4./Pi*DMbranching*exp(-pow((DMmass-particle.Etot[ip]*1.e-3)/DMwidth,2))/DMmass*1.e-3;
  		 } // ip
  	     }  //  iz
  	 }  //  ir
       }  //  particle.n_spatial_dimensions==2
     
  // assign the source function (3D)
  
     if(galaxy.n_spatial_dimensions==3)
       {
!        for(int ix=0; ix<gcr[0].n_xgrid; ix++)
  	 {
  	   for(int iy=0; iy<gcr[0].n_ygrid; iy++)
  	     {
***************
*** 260,300 ****
  			 {
  			   if(DME0<particle.Ekin[ip] || DME0/DMwidth>particle.Ekin[ip]) continue;
  			   particle.secondary_source_function.d3[ix][iy][iz].s[ip]
! 			     +=DM_profile_av(galaxy.r[ix], galaxy.r[iy], galaxy.z[iz], galaxy.dx, galaxy.dy, galaxy.dz)
  			     *DMsecondary_spectrum*DMbranching/4./Pi*C;
  			   continue;
! 			 } // end of DarkSUSY area
! 
  		       if(particle.Etot[ip]*1.e-3<=DMmass) 
! 			 {
!                           if(particle.Ekin[ip]*1.e-3<pow(10,-8.9)*DMmass)
!                             particle.secondary_source_function.d3[ix][iy][iz].s[ip]+=0;
!                           else
!                               {
!                                jDMyw=lround(100.*log10(particle.Ekin[ip]/(DMmass*1000.)))+NsDMym-1;
! 		               particle.secondary_source_function.d3[ix][iy][iz].s[ip]+=(1.+SD_key)*(C/(4.*Pi))*0.5*DMcs_v*
!                                DM_profile_av(galaxy.x[ix], galaxy.y[iy], galaxy.z[iz], galaxy.dx, galaxy.dy, galaxy.dz)*pow(DMmass,-2.)*DM_subs_boost(galaxy.x[ix], galaxy.y[iy], galaxy.z[iz])*DMym[jDMyw]/(log(10.)*particle.Ekin[ip]);
!                               } //else  
!                           } // if 
  		     } //ip
  		 }  //  iz
  	     }  //  iy
! 	 }  //  ix 
! if(galdef.verbose>=3)
! for(int ix=0; ix<gcr[0].n_xgrid; ix++)	  {
! for(int iy=0; iy<gcr[0].n_ygrid; iy++)	  {
! for(int iz=0; iz<gcr[0].n_zgrid; iz++)	  {
! for(int ip=0; ip<particle.n_pgrid; ip++)  {
! cout<<galaxy.x[ix]<<" x "<<galaxy.y[iy]<<" y "<<galaxy.z[iz]<<" z "<<particle.Ekin[ip]<<" Ekin "<<DM_profile_av(galaxy.x[ix], galaxy.y[iy], galaxy.z[iz], galaxy.dx, galaxy.dy, galaxy.dz)<<" rho_{DM}_sq_av "<<DM_subs_boost(galaxy.x[ix], galaxy.y[iy], galaxy.z[iz])<<" B(r) "<<particle.secondary_source_function.d3[ix][iy][iz].s[ip]<<endl;  }}}} //test printout
       }  //  particle.n_spatial_dimensions==3
   
  
     if(galdef.verbose>=2)
       {
         cout<<"   particle.secondary_source_function for "<<particle.name<<endl;
         particle.secondary_source_function.print();
       }
!    cout<<" <<<< gen_DM_source - exit"<<endl;
     return stat;
  }
  
--- 133,160 ----
  			 {
  			   if(DME0<particle.Ekin[ip] || DME0/DMwidth>particle.Ekin[ip]) continue;
  			   particle.secondary_source_function.d3[ix][iy][iz].s[ip]
! 			     +=pow(DM_profile_av(galaxy.r[ix], galaxy.r[iy], galaxy.z[iz], galaxy.dx, galaxy.dy, galaxy.dz, dzz),2)
  			     *DMsecondary_spectrum*DMbranching/4./Pi*C;
  			   continue;
! 			 }
  		       if(particle.Etot[ip]*1.e-3<=DMmass) 
! 			 particle.secondary_source_function.d3[ix][iy][iz].s[ip]+= DMcs_v*
! 			   pow(DM_profile_av(galaxy.x[ix], galaxy.y[ix], galaxy.z[iz], galaxy.dx, galaxy.dy, galaxy.dz, dzz)/DMmass,2)
! 		       *C/4./Pi*DMbranching*exp(-pow((DMmass-particle.Etot[ip]*1.e-3)/DMwidth,2))/DMmass*1.e-3;
  		     } //ip
  		 }  //  iz
  	     }  //  iy
! 	 }  //  ix
       }  //  particle.n_spatial_dimensions==3
   
+  // test printout
  
     if(galdef.verbose>=2)
       {
         cout<<"   particle.secondary_source_function for "<<particle.name<<endl;
         particle.secondary_source_function.print();
       }
!    INFO("Exit");
     return stat;
  }
  
***************
*** 303,472 ****
  int Galprop::gen_DM_emiss()
  {
     INFO("Entry");
-    cout<<"gen_DM_emiss"<<endl;
-    cout<<"generating DM prompt gamma emissivity for n_spatial_dimensions="<<galdef.n_spatial_dimensions<<endl;
- 
     double 
!      DMmass      =galdef.DM_double2,                  // DM particle mass, GeV
!      DMcs_v      =galdef.DM_double9;                  // DM <cross_sec*V> -thermally overaged, cm3 s-1 
!    int stat=0, iwm=0, channel_key=galdef.DM_int2;     // last one sets annihilation channel
! 
!    FILE *fDMg;                                                 //file with annihilation yields data for gammas
!    const long NsDMy=55242, NDMm=62, NsDMym=891;             // for operation with yields data 
!    long jDMyw=0;
!    double DMy[NsDMy], DMym[NsDMym];                                      
!    const double mt[NDMm]={5.,6.,8.,10.,15.,20.,25.,30.,40.,50.,60.,70.,80.,90.,100.,110.,120.,130.,140.,150.,160.,180.,200.,220.,240.,260.,280.,300.,330.,360.,
! 400.,450.,500.,550.,600.,650.,700.,750.,800.,900.,1000.,1100.,1200.,1300.,1500.,1700.,2000.,2500.,3000.,4000.,5000.,6000.,7000.,
! 8000.,9000.,10000.,12000.,15000.,20000.,30000.,50000.,100000.};   // masses with tabulated yields
!    const std::string DMDirectory = configure.fFITSDataDirectory+"DM/";
!    std::string filename = DMDirectory;
!    const char *str;
!   
! 
!  switch(channel_key)
!   {
!      case 1: filename += "DM-e-g.dat";
!              str = filename.c_str();	
!              fDMg=fopen(str,"r");
!              break; // e^+e^- channel
!      case 2: filename += "DM-mu-g.dat";
!              str = filename.c_str();	
!              fDMg=fopen(str,"r");
!              break; // \mu^+\mu^- channel
!      case 3: filename += "DM-tau-g.dat";
!              str = filename.c_str();	
!              fDMg=fopen(str,"r");
!              break; // \tau^+\tau^- channel
!      case 4: filename += "DM-q-g.dat";
!              str = filename.c_str();	
!              fDMg=fopen(str,"r");
!              break; // qq* channel
!      case 5: filename += "DM-c-g.dat";
!              str = filename.c_str();	
!              fDMg=fopen(str,"r");
!              break; // cc* channel
!      case 6: filename += "DM-b-g.dat";
!              str = filename.c_str();	
!              fDMg=fopen(str,"r");
!              break; // bb* channel
!      case 7: filename += "DM-t-g.dat";
!              str = filename.c_str();	
!              fDMg=fopen(str,"r");
!              break; // tt* channel
!      case 8: filename += "DM-g-g.dat";
!              str = filename.c_str();	
!              fDMg=fopen(str,"r");
!              break; // \gamma\gamma channel
!      case 9: filename += "DM-gl-g.dat";
!              str = filename.c_str();	
!              fDMg=fopen(str,"r");
!              break; // gg channel
!      case 10: filename += "DM-W-g.dat";
!              str = filename.c_str();	
!              fDMg=fopen(str,"r");
!              break; // W^+W^- channel
!      case 11: filename += "DM-Z-g.dat";
!              str = filename.c_str();	
!              fDMg=fopen(str,"r");
!              break; // ZZ channel
!      case 12: filename += "DM-h-g.dat";
!              str = filename.c_str();	
!              fDMg=fopen(str,"r");
!              break; // hh channel
!   }
! 
!  fseek(fDMg, 0, SEEK_SET);
!  for (long jDMy=0; jDMy<NsDMy; jDMy++)
!       {
!        fscanf(fDMg, "%lf", &DMy[jDMy]);
!       }
!  fclose(fDMg);
! 
! 
!  for(int ia=0; ia<NDMm; ia++) 
!     {
!      if(DMmass==mt[ia]) 
!        {iwm=ia+1;                                                       // yields preparation from mass analysis
!         break;
!        }
!     }
!  if(iwm>=1)
!    {
!     for(int ib=0; ib<NsDMym; ib++) DMym[ib]=DMy[(iwm-1)*NsDMym+ib];
!    }
!  else
!    {
!     while (DMmass>mt[iwm]) iwm++;
!     for(int ic=0;ic<NsDMym;ic++) DMym[ic]=DMy[(iwm-1)*NsDMym+ic]+((DMy[iwm*NsDMym+ic]-DMy[(iwm-1)*NsDMym+ic])*(DMmass-mt[iwm-1]))/(mt[iwm]-mt[iwm-1]);
!    } 
  
     galaxy.DM_emiss=0.;
  
  // define the spectra of annihilation products: gammas
     
     if(galdef.n_spatial_dimensions==2)
!      {  
! #pragma omp parallel for schedule(dynamic) default(shared) private(jDMyw)
!        for(int ir=0; ir<galaxy.n_rgrid; ir++)
  	 {
! 	   for(int iz=0; iz<galaxy.n_zgrid; iz++)
  	     {
                 for(int iEgamma=0; iEgamma<galaxy.n_E_gammagrid; iEgamma++)
  		 {
! 		    if(galaxy.E_gamma[iEgamma]*1.e-3<=DMmass) 
!                       {
!                        if(galaxy.E_gamma[iEgamma]*1.e-3<pow(10,-8.9)*DMmass)
!                           galaxy.DM_emiss.d2[ir][iz].s[iEgamma]+=0;
!                        else
!                            {
!                             jDMyw=lround(100.*log10(galaxy.E_gamma[iEgamma]/(DMmass*1000.)))+NsDMym-1;
! 		            galaxy.DM_emiss.d2[ir][iz].s[iEgamma]+=(1/(4.*Pi))*0.5*DMcs_v*
!                           DM_profile_av(galaxy.r[ir], galaxy.z[iz], galaxy.dr, galaxy.dz)*pow(DMmass,-2.)*DM_subs_boost(galaxy.r[ir], 0., galaxy.z[iz])*DMym[jDMyw]/(log(10.)*galaxy.E_gamma[iEgamma]);
!                            } // else  
!                        } // if 
! 		  } // iEgamma
! 	     } // iz
! 	 } // ir
! if(galdef.verbose>=3)
! for(int ir=0; ir<galaxy.n_rgrid; ir++)	                      {
! for(int iz=0; iz<galaxy.n_zgrid; iz++)	                      {
! for(int iEgamma=0; iEgamma<galaxy.n_E_gammagrid; iEgamma++)   {
! cout<<galaxy.r[ir]<<" r "<<galaxy.z[iz]<<" z "<<galaxy.E_gamma[iEgamma]<<" Egamma "<<DM_profile_av(galaxy.r[ir], galaxy.z[iz], galaxy.dr, galaxy.dz)<<" rho_{DM}_sq_av "<<DM_subs_boost(galaxy.r[ir], 0., galaxy.z[iz])<<" B(r) "<<galaxy.DM_emiss.d2[ir][iz].s[iEgamma]<<endl;  }}} //test printout
!      } // if n_sp._dim.
! 
     if(galdef.n_spatial_dimensions==3)
       {
! #pragma omp parallel for schedule(dynamic) default(shared) private(jDMyw)
!     for(int ix=0; ix<galaxy.n_xgrid; ix++)
  	 {
! 	   for(int iy=0; iy<galaxy.n_ygrid; iy++)
  	     {
! 	       for(int iz=0; iz<galaxy.n_zgrid; iz++)
  		 {
  		   for(int iEgamma=0; iEgamma<galaxy.n_E_gammagrid; iEgamma++)
  		     {
! 		       if(galaxy.E_gamma[iEgamma]*1.e-3<=DMmass) 
!                          {
!                           if(galaxy.E_gamma[iEgamma]*1.e-3<pow(10,-8.9)*DMmass)
!                              galaxy.DM_emiss.d3[ix][iy][iz].s[iEgamma]+=0;
!                           else
!                               {
!                                jDMyw=lround(100.*log10(galaxy.E_gamma[iEgamma]/(DMmass*1000.)))+NsDMym-1;
! 		               galaxy.DM_emiss.d3[ix][iy][iz].s[iEgamma]+=(1/(4.*Pi))*0.5*DMcs_v*
!                          DM_profile_av(galaxy.x[ix], galaxy.y[iy], galaxy.z[iz], galaxy.dx, galaxy.dy, galaxy.dz)*pow(DMmass,-2.)*DM_subs_boost(galaxy.x[ix], galaxy.y[iy], galaxy.z[iz])*DMym[jDMyw]/(log(10.)*galaxy.E_gamma[iEgamma]);
!                               } // else  
!                          } // if 
! 		     } // iEgamma
! 		 } // iz
! 	     } // iy
! 	 } // ix
! if(galdef.verbose>=3)
! for(int ix=0; ix<galaxy.n_xgrid; ix++)	                      {
! for(int iy=0; iy<galaxy.n_ygrid; iy++)	                      {
! for(int iz=0; iz<galaxy.n_zgrid; iz++)		              {
! for(int iEgamma=0; iEgamma<galaxy.n_E_gammagrid; iEgamma++)   {
! cout<<galaxy.x[ix]<<" x "<<galaxy.y[iy]<<" y "<<galaxy.z[iz]<<" z "<<galaxy.E_gamma[iEgamma]<<" Egamma "<<DM_profile_av(galaxy.x[ix], galaxy.y[iy], galaxy.z[iz], galaxy.dx, galaxy.dy, galaxy.dz)<<" rho_{DM}_sq_av "<<DM_subs_boost(galaxy.x[ix], galaxy.y[iy], galaxy.z[iz])<<" B(r) "<<galaxy.DM_emiss.d3[ix][iy][iz].s[iEgamma]<<endl;  }}}} //test printout
!      } // if n_sp._dim.
     INFO("Exit");
     return(stat);
  }
--- 163,228 ----
  int Galprop::gen_DM_emiss()
  {
     INFO("Entry");
     double 
!      DMmass      =galdef.DM_double2, // DM particle mass
!      DMcs_v      =galdef.DM_double9, // DM <cross_sec*V> -thermally overaged, cm3 s-1 
!      DMbranching =0.1,
!      dzz=0.01;                       // kpc, gas averaging step
!    int stat=0;
  
     galaxy.DM_emiss=0.;
  
  // define the spectra of annihilation products: gammas
     
     if(galdef.n_spatial_dimensions==2)
!      {
!        ostringstream os;
!        os<<"generating DM emissivity for n_spatial_dimensions="<<galdef.n_spatial_dimensions;
!        INFO(os.str());
!        for(int ir=0; ir<gcr[0].n_rgrid; ir++)
  	 {
! 	   for(int iz=0; iz<gcr[0].n_zgrid; iz++)
  	     {
                 for(int iEgamma=0; iEgamma<galaxy.n_E_gammagrid; iEgamma++)
  		 {
! 		   if(galaxy.E_gamma[iEgamma]*1.e-3>DMmass) 
! 		     {
! 		       galaxy.DM_emiss.d2[ir][iz].s[iEgamma]=0;
! 		       continue;
! 		     }
! 		   galaxy.DM_emiss.d2[ir][iz].s[iEgamma]= DMcs_v *DMbranching/(4.*Pi)// sr^-1 IMOS20060420
! 		     *pow(DM_profile_av(galaxy.r[ir], galaxy.z[iz], galaxy.dr, galaxy.dz, dzz)/DMmass,2)
! 		     /galaxy.E_gamma[iEgamma];
! 		 }
! 	     }
! 	 }
!      }
     if(galdef.n_spatial_dimensions==3)
       {
!        ostringstream os;
!        os<<"generating DM emissivity for n_spatial_dimensions="<<galdef.n_spatial_dimensions;
!        INFO(os.str());
!        for(int ix=0; ix<gcr[0].n_rgrid; ix++)
  	 {
! 	   for(int iy=0; iy<gcr[0].n_rgrid; iy++)
  	     {
! 	       for(int iz=0; iz<gcr[0].n_zgrid; iz++)
  		 {
  		   for(int iEgamma=0; iEgamma<galaxy.n_E_gammagrid; iEgamma++)
  		     {
! 		       if(galaxy.E_gamma[iEgamma]*1.e-3>DMmass) 
! 			 {
! 			   galaxy.DM_emiss.d3[ix][iy][iz].s[iEgamma]=0;
! 			   continue;
! 			 }
! 		       galaxy.DM_emiss.d3[ix][iy][iz].s[iEgamma]=  DMcs_v *DMbranching/(4.*Pi) // sr^-1 IMOS20060420
! 			 *pow(DM_profile_av(galaxy.x[ix], galaxy.y[ix], galaxy.z[iz], galaxy.dx, galaxy.dy, galaxy.dz, dzz)/DMmass,2)
! 			 /galaxy.E_gamma[iEgamma];
! 		     }
! 		 }
! 	     }
! 	 }
!      }
     INFO("Exit");
     return(stat);
  }
***************
*** 476,613 ****
  double Galprop::DM_profile(double Xkpc, double Ykpc, double Zkpc)
  {
    double R=sqrt(Xkpc*Xkpc+Ykpc*Ykpc+Zkpc*Zkpc),
!     Rc         =galdef.DM_double0, //core radius, kpc
!     rho0       =galdef.DM_double1, //scale DM mass density, GeV cm^-3
!     Rtr        =galdef.DM_double8, //truncation radius for the NFW profile, where density goes flat, kpc
!     aEin       =galdef.DM_double7, //\alpha parameter for the Einasto profile
!     gammaNFW   =galdef.DM_double6; //\gamma parameter for the generalized NFW profile
    int profile_key =galdef.DM_int0; //profile type
    
    switch(profile_key)
      {
!     case 0:   //generalized NFW profile
!       return(rho0*pow(fmax(R,Rtr)/Rc,-gammaNFW)*pow(1.+fmax(R,Rtr)/Rc,gammaNFW-3.));
!       break;
        
!     case 1:   //Isothermal profile
!       return(rho0/(1.+pow(R/Rc,2.)));
!       break;
        
!     case 2:   //Einasto profile
!       return(rho0*exp(-2./aEin*(pow(R/Rc,aEin)-1.)));
!       break;
        
!     case 3:   //Burkert profile
!       return(rho0/((1.+R/Rc)*(1.+pow(R/Rc,2.))));
!       break;
! 
!     case 8:
!       if(round(Xkpc*10)/10==15 && round(Ykpc*10)/10==-10.8 &&  round(Zkpc*10)/10==-5) return 20;
!       else return 0;
!       break;	
        
!     /* case 9:   //DarkSUSY profile (use only if the DarkSUSY and GALPROP combined) IMOS20060901
!       RHO_DARKSUSY_F77(&Xkpc,&Ykpc,&Zkpc,&rho0);
        if(rho0<0.)
  	{
! 	  cout<<"gen_DM_source: rho_darksusy() function is not defined"<<endl;
  	  exit(0);
  	}
        return(rho0);
-       break; */
  
!     default: cout << "No valid DM profile specified!" << endl;
      }
  }
! //**.****|****.****|****.****|****.****|****.****|****.****|****.****|****.****|  
! 
!  double Galprop::DM_profile_av(double r,double z,double dr,double dz)
!    {  
!      double DM_profile_av_=0., rho0 =galdef.DM_double1, dd=0.01;
!      int nuse=0, profile_key =galdef.DM_int0; 
  
-    if (r<1.e-6 && abs(z)<1.e-6) 
-      {  
-       for (double zz=z-0.5*dz; zz<z+(0.5+0.02*dd)*dz; zz+=0.1*dd*dz)
-             {
-              for (double rr=0; rr<r+(0.5+0.02*dd)*dr; rr+=0.1*dd*dr)
- 	         { 
- 	           DM_profile_av_+=DM_profile(rr,0.,zz)*DM_profile(rr,0.,zz);
- 	           nuse++; 
- 	         } //rr
-              } //zz
-          return (DM_profile_av_/nuse);
-     }  //if
- 
-    else 
-        {
-         for (double zz=z-0.5*dz; zz<z+(0.5+0.2*dd)*dz; zz+=dd*dz)
-             {
-              for (double rr=r-0.5*dr; rr<r+(0.5+0.2*dd)*dr; rr+=dd*dr)
- 	         { 
- 	           if (rr<0.) continue;
- 	           DM_profile_av_+=DM_profile(rr,0.,zz)*DM_profile(rr,0.,zz);
- 	           nuse++; 
- 	         } //rr
-              } //zz
-          return (DM_profile_av_/nuse);
-         }  //else
-     }
-    
-  
  //**.****|****.****|****.****|****.****|****.****|****.****|****.****|****.****|
  
!  
!  double Galprop::DM_profile_av(double x,double y,double z,double dx,double dy,double dz)
!   {  
!      double DM_profile_av_=0., rho0 =galdef.DM_double1, dd=0.1;
!      int nuse =0, profile_key =galdef.DM_int0; 
! 
!   if (abs(x)<1.e-6 && abs(y)<1.e-6 && abs(z)<1.e-6) 
!      {  
!       for (double zz=z-0.5*dz; zz<z+(0.5+0.02*dd)*dz; zz+=0.1*dd*dz)
!            {
!             for (double xx=x-0.5*dx; xx<x+(0.5+0.02*dd)*dx; xx+=0.1*dd*dx)
!                 {
!                  for (double yy=y-0.5*dy; yy<y+(0.5+0.02*dd)*dy; yy+=0.1*dd*dy)
! 	             {
! 	               DM_profile_av_+=DM_profile(xx,yy,zz)*DM_profile(xx,yy,zz);
! 	               nuse++;
! 	             } //yy
!                 } //xx
!            } //zz
!        return (DM_profile_av_/nuse);
!     }  //if
! 
!   else {
!         for (double zz=z-0.5*dz; zz<z+(0.5+0.2*dd)*dz; zz+=dd*dz)
!            {
!             for (double xx=x-0.5*dx; xx<x+(0.5+0.2*dd)*dx; xx+=dd*dx)
!                 {
!                  for (double yy=y-0.5*dy; yy<y+(0.5+0.2*dd)*dy; yy+=dd*dy)
! 	             {
! 	               DM_profile_av_+=DM_profile(xx,yy,zz)*DM_profile(xx,yy,zz);
! 	               nuse++;
! 	             } //yy
!                 } //xx
!            } //zz
!        return (DM_profile_av_/nuse);
!       } //else
!     }
   
  //**.****|****.****|****.****|****.****|****.****|****.****|****.****|****.****|
   
!  double Galprop::DM_subs_boost(double Xkpc, double Ykpc, double Zkpc)
!   {
!     double R = sqrt(Xkpc*Xkpc+Ykpc*Ykpc+Zkpc*Zkpc);
!     int boost_key = galdef.DM_int3;  //switch boost on/off
!       switch(boost_key)
!        {
!          case 0: return(1.);  //no boost
! 
!          case 1: return(1.00254+0.0481409*R-0.00568977*R*R+0.0012815*pow(R,3.)-0.0000601459*pow(R,4.)+1.78452e-6*pow(R,5.)-2.69758e-8*pow(R,6.)+2.02793e-10*pow(R,7.)-5.97113e-13*pow(R,8.)); //polynomial fit of B(r)
! 
!        }
!   }
! 
   
--- 232,304 ----
  double Galprop::DM_profile(double Xkpc, double Ykpc, double Zkpc)
  {
    double R=sqrt(Xkpc*Xkpc+Ykpc*Ykpc+Zkpc*Zkpc),
!     Rsun =8.5,                     //kpc, galactocentric distance of the solar system 
!     Rc         =galdef.DM_double0, //core radius
!     rho0       =galdef.DM_double1; //local DM mass density
    int profile_key =galdef.DM_int0; //profile type
    
    switch(profile_key)
      {
!     case 0:   //NFW profile
!       return(rho0*Rc/R*pow(1.+R/Rc,-2));
        
!     case 1:   //isothermal profile
!       return(rho0*(pow(Rc,2)+pow(Rsun,2))/(pow(Rc,2)+pow(R,2)));
        
!     case 2:   //Evans profile
!       return(rho0*pow(pow(Rc,2)+pow(Rsun,2),2)/(3.*pow(Rc,2)+pow(Rsun,2))
! 	     *(3.*pow(Rc,2)+pow(R,2))/pow(pow(Rc,2)+pow(R,2),2));
        
!     case 3:   //alternative profile
!       return(rho0*pow(Rc+Rsun,2)/pow(Rc+R,2));
        
!     case 9:   //DarkSUSY profile (use only if the DarkSUSY and GALPROP combined) IMOS20060901
!       rho0 = rho_darksusy_cc(Xkpc,Ykpc,Zkpc);
! 
        if(rho0<0.)
  	{
! 	  FATAL("gen_DM_source: rho_darksusy() function is not defined");
  	  exit(0);
  	}
        return(rho0);
  
!     default:
!       return(rho0);
      }
  }
!   
  
  //**.****|****.****|****.****|****.****|****.****|****.****|****.****|****.****|
  
!  double Galprop::DM_profile_av(double r,double z,double dr,double dz,double dzz)
!    {  
!      double DM_profile_av_=0.0;
!      int nuse=0;
!      
!      for (double zz=z-dz/2.; zz<=z+dz/2.; zz+=dzz)
!        for (double rr=r-dr/2.; rr<=r+dr/2.; rr+=dr/10.)
! 	 { 
! 	   if (rr<0.) continue;
! 	   DM_profile_av_+=DM_profile(rr,0,zz);
! 	   nuse++; 
! 	 }
!      return (DM_profile_av_/nuse);
!    }
   
  //**.****|****.****|****.****|****.****|****.****|****.****|****.****|****.****|
   
!  double Galprop::DM_profile_av(double x,double y,double z,double dx,double dy,double dz,double dzz)
!    {  
!      double DM_profile_av_=0.0;
!      int nuse=0;
!      
!      for (double zz=z-dz/2.; zz<=z+dz/2.; zz+=dzz)
!        for (double xx=x-dx/2.; xx<=x+dx/2.; xx+=dx/10.)
! 	 for (double yy=y-dy/2.; yy<=y+dy/2.; yy+=dy/10.)
! 	   {
! 	     DM_profile_av_+=DM_profile(xx,yy,zz);
! 	     nuse++;
! 	   }
!      return DM_profile_av_/nuse;
!    }
   
diff -c source/nH.cc /home/aegorov/g56o/source/nH.cc
*** source/nH.cc	2022-01-26 15:38:21.324330744 +0100
--- /home/aegorov/g56o/source/nH.cc	2021-11-30 22:19:15.920703971 +0100
***************
*** 79,85 ****
  
  namespace nH_models {
     int nHI_model=2, nH2_model=2, nHII_model=1; // intialize to original models
-    double nHII_norm = 0;
     int debug=0; 
  
     std::vector<std::unique_ptr<GalacticStructure::CylindricalProfile> > nHI_prof, nH2_prof, nHII_prof; // using libgalstruct for more runtime configurability
--- 79,84 ----
***************
*** 184,191 ****
    nHI_model = galdef.nHI_model;
    nH2_model = galdef.nH2_model;
    nHII_model= galdef.nHII_model;
-   nHII_norm = galdef.DM_double4; 
-  
    debug=0;
  
    ostringstream buf;
--- 183,188 ----
***************
*** 269,278 ****
          //The default model
          result = nHI(r, z);//(3 == galaxy.n_spatial_dimensions && r <= 1.52 ? MilkyWayAnalyticBulge::HIAnalyticBulgeDensity(x, y, z) : nHI(r, z));
          break;
-      case 3:
-         result = 0; //test
-      case 4:
-         result = 0.269*(0.42*pow(10,sin(Pi/2*pow(r/11.5,1.35)))+r*r/529+0.23/pow(r+1.8,0.7))*exp(-z*z/0.0072); //M31   
  
       case 9:
          {
--- 266,271 ----
***************
*** 351,360 ****
          //The default model
          result = nH2(r, z, xCO);//(3 == galaxy.n_spatial_dimensions && r <= 1.22 ? MilkyWayAnalyticBulge::H2AnalyticBulgeDensity(x, y, z) : nH2(r, z, xCO));
          break;
-      case 3:
-         result = 0; //test
-      case 4:
-         result = 0.538*(0.073+0.42*exp(-pow(r-4.35,2))+exp(-pow(r-10.8,2)/3.5))*exp(-z*z/0.0018); //M31   
  
       case 9:
          {
--- 344,349 ----
***************
*** 587,599 ****
          result = nHII(r, z);
  
          break;
-         
-      case 4: result = nHII_norm*exp(-r*r/100-fabs(z));   //M31
-         break; 
-         
-      case 5: result = 0.1;   //M31-test
-         break;   
-   
  
       case 9:
          {
--- 576,581 ----
diff -c source/store_synch_emiss.cc /home/aegorov/g56o/source/store_synch_emiss.cc
*** source/store_synch_emiss.cc	2021-01-26 20:23:41.059799404 +0100
--- /home/aegorov/g56o/source/store_synch_emiss.cc	2021-11-30 22:16:17.239379253 +0100
***************
*** 48,60 ****
    valarray<double> array(0., nElements);
  
    // for 3D case store x-dimension at y=0
-  
- //AE20201229 
-  int stokes_max; 
-  if(galdef.synchrotron==2) stokes_max=1;
-  if(galdef.synchrotron==3) stokes_max=3;
    
!   for(int stokes=0;stokes<stokes_max;stokes++)        //AWS20100708 + AE20201229
    {
  
    int i = 0;
--- 48,55 ----
    valarray<double> array(0., nElements);
  
    // for 3D case store x-dimension at y=0
    
!   for(int stokes=0;stokes<=2;stokes++)//AWS20100708
    {
  
    int i = 0;
diff -c source/store_synch_skymap.cc /home/aegorov/g56o/source/store_synch_skymap.cc
*** source/store_synch_skymap.cc	2021-01-26 20:23:41.060799422 +0100
--- /home/aegorov/g56o/source/store_synch_skymap.cc	2021-11-30 22:16:42.241844473 +0100
***************
*** 30,36 ****
      filename =       configure.fOutputDirectory + configure.fOutputPrefix + "synchrotron_healpix_" + galdef.galdef_ID + ".gz";                      //AWS20100107
      SM::writeToFits(*galaxy.synchrotron_hp_skymap, filename, true, true, "Frequency", "Hz");
  
-    if(galdef.synchrotron==3) {                                                  //AE20201229
      filename =       configure.fOutputDirectory + configure.fOutputPrefix + "synchrotron_Q_healpix_" + galdef.galdef_ID + ".gz";                    //AWS20100709
      SM::writeToFits(*galaxy.synchrotron_Q_hp_skymap, filename, true, true, "Frequency", "Hz");
      
--- 30,35 ----
***************
*** 45,51 ****
  
      filename =       configure.fOutputDirectory + configure.fOutputPrefix + "synchrotron_polfra_healpix_" + galdef.galdef_ID + ".gz";             //AWS20110922
      SM::writeToFits(*galaxy.synchrotron_polfra_hp_skymap, filename, true, true, "Frequency", "Hz");
- 	} // synchrotron=3
  
      filename =       configure.fOutputDirectory + configure.fOutputPrefix + "free_free_healpix_" + galdef.galdef_ID + ".gz";             //AWS20110906
      if ( galdef.free_free_absorption >= 1 ) 
--- 44,49 ----
